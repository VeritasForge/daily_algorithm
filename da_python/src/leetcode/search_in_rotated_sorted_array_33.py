"""
LeetCode 33. Search in Rotated Sorted Array
https://leetcode.com/problems/search-in-rotated-sorted-array/

난이도: Medium

문제 설명:
정수 배열 nums가 오름차순으로 정렬되어 있고, 배열의 값들은 모두 고유합니다.

배열이 어떤 피벗 인덱스 k (1 <= k < nums.length)에서 회전되어
[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] 형태가 됩니다.
예를 들어, [0,1,2,4,5,6,7]이 피벗 인덱스 3에서 회전되면 [4,5,6,7,0,1,2]가 됩니다.

회전된 배열 nums와 정수 target이 주어지면, target이 nums에 있으면 그 인덱스를 반환하고,
없으면 -1을 반환합니다.

O(log n) 시간 복잡도의 알고리즘을 작성해야 합니다.

예제 1:
    Input: nums = [4,5,6,7,0,1,2], target = 0
    Output: 4

예제 2:
    Input: nums = [4,5,6,7,0,1,2], target = 3
    Output: -1

예제 3:
    Input: nums = [1], target = 0
    Output: -1

제약 조건:
    - 1 <= nums.length <= 5000
    - -10^4 <= nums[i] <= 10^4
    - nums의 모든 값은 고유함
    - nums는 오름차순 정렬 후 회전된 배열
    - -10^4 <= target <= 10^4
"""

"""
⏺ 📝 LeetCode 33. Search in Rotated Sorted Array 복습 노트

  ---
  1. 문제 핵심

  - 정렬된 배열이 어느 지점에서 회전됨
  - O(log n) 시간 복잡도 → 이진 탐색 사용
  - 일반 이진 탐색을 그대로 쓸 수 없음 (회전점 때문에)

  원래:   [0, 1, 2, 4, 5, 6, 7]
  회전 후: [4, 5, 6, 7, 0, 1, 2]

  ---
  2. 핵심 아이디어

  회전된 배열을 반으로 나누면, 적어도 한쪽은 반드시 정렬되어 있다

  회전점은 하나뿐이므로, 회전점이 없는 쪽은 정렬 상태 유지!
  ┌─────────────────┬──────────────┬────────────┐
  │   회전점 위치   │     왼쪽     │   오른쪽   │
  ├─────────────────┼──────────────┼────────────┤
  │ 오른쪽에 있음   │ ✅ 정렬됨    │ ❌ 또는 ✅ │
  ├─────────────────┼──────────────┼────────────┤
  │ 왼쪽에 있음     │ ❌ 정렬 안됨 │ ✅ 정렬됨  │
  ├─────────────────┼──────────────┼────────────┤
  │ 정확히 mid 경계 │ ✅ 정렬됨    │ ✅ 정렬됨  │
  └─────────────────┴──────────────┴────────────┘
  ---
  3. 헷갈렸던 개념들

  🤔 Q1: 회전점이 뭐야?

  회전점 = 가장 작은 값의 위치 = 원래 배열의 시작점이 이동한 위치

  [4, 5, 6, 7, 0, 1, 2]
              ^
           회전점 (index 4, 값 0)

  앞의 값(7)보다 작아지는 지점!

  ❌ "0이 시작되는 곳"이 아니라
  ✅ "가장 작은 값이 있는 곳"

  ---
  🤔 Q2: mid는 어떻게 계산해?

  mid = (left + right) // 2

  [4, 5, 6, 7, 0, 1, 2]
   0  1  2  3  4  5  6  ← index

  left=0, right=6
  mid = (0+6)//2 = 3  → 값은 7

  mid는 index이지, 값이 아님!

  ---
  🤔 Q3: "왼쪽 구간"은 어디까지야?

  왼쪽 구간 = left ~ mid (mid 포함!)

  [4, 5, 6, 0, 1, 2, 3]
   ^        ^
  left     mid

  왼쪽 구간: [4, 5, 6, 0]  ← mid 포함!

  [4, 5, 6]만 보면 정렬됐지만, mid(값 0)까지 포함하면 정렬 안됨!

  ---
  🤔 Q4: nums[left] <= nums[mid]로 왜 정렬 여부를 알 수 있어?

  정렬된 구간의 특성: 시작값 <= 끝값 (오름차순)

  정렬된 구간:        정렬 안된 구간:
  [4, 5, 6, 7]       [6, 7, 0, 1]
   ^        ^         ^        ^
   4   <=   7  ✅     6   >    1  ❌

  회전점이 포함된 구간은 중간에 "뚝 떨어지는 곳"이 있어서 시작 > 끝이 됨!

  ---
  🤔 Q5: 왼쪽이 정렬되면 오른쪽도 정렬된 거 아냐?

  맞다! 양쪽 다 정렬된 경우도 있음

  [4, 5, 6, 7, 0, 1, 2]  ← 회전점이 정확히 mid 경계

  왼쪽: [4,5,6,7] ✅
  오른쪽: [0,1,2] ✅

  하지만 알고리즘에서는 **"확실히 정렬된 구간 하나"**만 찾으면 충분!

  ---
  🤔 Q6: 왜 정렬된 구간을 찾아야 해?

  정렬된 구간에서만 "범위 체크"가 가능하기 때문!

  정렬된 [4, 5, 6, 7]에서 target=5 찾기:
  → 4 <= 5 <= 7?  ✅ 범위 안에 있다!

  정렬 안된 [6, 7, 0, 1]에서 target=5 찾기:
  → 6 <= 5 <= 1?  🤷 의미 없음...

  정렬 안된 구간은 시작/끝만 봐서 target 존재 여부를 알 수 없음!

  ---
  4. 알고리즘 로직

  1. left, right 초기화
  2. while left <= right:
     a. mid 계산
     b. nums[mid] == target이면 반환

     c. 왼쪽이 정렬됐는지 확인 (nums[left] <= nums[mid])
        - 정렬됐다면:
          - target이 왼쪽 범위 안에 있으면 → right = mid - 1
          - 아니면 → left = mid + 1
        - 정렬 안됐다면 (= 오른쪽이 정렬됨):
          - target이 오른쪽 범위 안에 있으면 → left = mid + 1
          - 아니면 → right = mid - 1

  3. 못 찾으면 -1 반환

  ---
  5. 시간/공간 복잡도

  - 시간: O(log n) - 매번 탐색 범위가 절반으로 줄어듦
  - 공간: O(1) - 포인터 몇 개만 사용

  ---
  6. 핵심 기억할 것

  1. 회전점은 하나 → 반으로 나누면 한쪽은 반드시 정렬됨
  2. 정렬된 구간에서만 범위 체크 가능
  3. mid는 index로 계산 (left + right) // 2
  4. 왼쪽 구간은 mid 포함 [left ~ mid]
"""


def search(nums: list[int], target: int) -> int:
    """회전된 정렬 배열에서 target의 인덱스를 찾아 반환합니다.

    Args:
        nums: 회전된 정렬 배열
        target: 찾고자 하는 값

    Returns:
        target의 인덱스, 없으면 -1
    """
    left, right = 0, len(nums) - 1
    mid = (left + right) // 2

    if nums[left] <= nums[mid]:
        if nums[left] <= target <= nums[mid]:
            right = mid
        else:
            left = mid + 1
    else:
        if nums[mid] <= target <= nums[right]:
            left = mid
        else:
            right = mid - 1

    for i in range(left, right + 1):
        if nums[i] == target:
            return i

    return -1
